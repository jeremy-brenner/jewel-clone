// Generated by CoffeeScript 1.9.2
(function() {
  var AudioLoader, AudioManager, Background, Cell, FontBufferGeometry, Fps, Gem, GemCascade, GemFactory, Grid, Input, Logger, Main, Menu, MultiplierDisplay, ProgressMeter, RoamingLight, Score, ScoreBoard, Timer, init,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AudioLoader = (function() {
    function AudioLoader(file) {
      this.loadBuffer = bind(this.loadBuffer, this);
      this.fileLoaded = bind(this.fileLoaded, this);
      this.file = file;
      this.loaded = false;
      this.context = new AudioContext();
      this.loadFile(file);
    }

    AudioLoader.prototype.name = function() {
      return this.file.split('/').pop().split('.')[0];
    };

    AudioLoader.prototype.loadFile = function(file) {
      this.request = new XMLHttpRequest();
      this.request.open('GET', file, true);
      this.request.responseType = 'arraybuffer';
      this.request.onload = this.fileLoaded;
      return this.request.send();
    };

    AudioLoader.prototype.fileLoaded = function() {
      return this.context.decodeAudioData(this.request.response, this.loadBuffer);
    };

    AudioLoader.prototype.loadBuffer = function(buffer) {
      this.buffer = buffer;
      this.loaded = true;
      return this.onload();
    };

    AudioLoader.prototype.onload = function() {};

    return AudioLoader;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.AudioLoader = AudioLoader;

  AudioManager = (function() {
    function AudioManager(files) {
      this.fileLoaded = bind(this.fileLoaded, this);
      this.context = new AudioContext();
      this.buffers = {};
      this.buildNodes();
      this.buildGraph();
      this.audio_loaders = this.loadFiles(files);
    }

    AudioManager.prototype.buildNodes = function() {
      return this.nodes = {
        destination: this.context.destination,
        masterGain: this.context.createGain(),
        backgroundMusicGain: this.context.createGain(),
        coreEffectsGain: this.context.createGain(),
        effectsGain: this.context.createGain(),
        pausedEffectsGain: this.context.createGain()
      };
    };

    AudioManager.prototype.buildGraph = function() {
      this.nodes.masterGain.connect(this.nodes.destination);
      this.nodes.backgroundMusicGain.connect(this.nodes.masterGain);
      this.nodes.coreEffectsGain.connect(this.nodes.masterGain);
      this.nodes.effectsGain.connect(this.nodes.coreEffectsGain);
      return this.nodes.pausedEffectsGain.connect(this.nodes.coreEffectsGain);
    };

    AudioManager.prototype.loadFiles = function(files) {
      var af, file, j, len, results;
      results = [];
      for (j = 0, len = files.length; j < len; j++) {
        file = files[j];
        af = new GemCrusher.AudioLoader(file);
        af.onload = this.fileLoaded;
        results.push(af);
      }
      return results;
    };

    AudioManager.prototype.allLoaded = function() {
      var f, j, len, ref;
      ref = this.audio_loaders;
      for (j = 0, len = ref.length; j < len; j++) {
        f = ref[j];
        if (f.loaded === false) {
          return false;
        }
      }
      return true;
    };

    AudioManager.prototype.fileLoaded = function() {
      var f, j, len, ref;
      if (this.allLoaded()) {
        ref = this.audio_loaders;
        for (j = 0, len = ref.length; j < len; j++) {
          f = ref[j];
          this.buffers[f.name()] = f.buffer;
        }
        return this.onload();
      }
    };

    AudioManager.prototype.play = function(name) {
      var source;
      if (!this.buffers[name]) {
        return;
      }
      source = this.context.createBufferSource();
      source.buffer = this.buffers[name];
      source.connect(this.nodes.effectsGain);
      source.loop = false;
      return source.start();
    };

    AudioManager.prototype.onload = function() {};

    return AudioManager;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.AudioManager = AudioManager;

  Background = (function() {
    function Background() {
      this.size = 1000;
      this.drawBackground();
    }

    Background.prototype.drawBackground = function() {
      var bg, bgg;
      bg = new THREE.MeshLambertMaterial({
        map: THREE.ImageUtils.loadTexture('img/wallpaper.png')
      });
      bgg = new THREE.PlaneBufferGeometry(this.size, this.size);
      this.object = new THREE.Mesh(bgg, bg);
      this.object.position.x = this.size / 2;
      this.object.position.y = this.size / 2;
      return this.object.position.z = -100000;
    };

    Background.prototype.scale = function(s) {
      this.object.scale.multiplyScalar(s);
      this.object.position.x = this.size * s / 2;
      return this.object.position.y = this.size * s / 2;
    };

    return Background;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Background = Background;

  Cell = (function() {
    function Cell(x, y) {
      this.tweenTick = bind(this.tweenTick, this);
      this.x = x;
      this.y = y;
      this.buildSquare();
    }

    Cell.prototype.xPos = function() {
      return this.x + 0.5;
    };

    Cell.prototype.yPos = function() {
      return this.y + 0.5;
    };

    Cell.prototype.commitNew = function() {
      this.gem = this.new_gem;
      return this.new_gem = null;
    };

    Cell.prototype.hasSomeHope = function(matches) {
      var doomed, j, len, match;
      doomed = true;
      for (j = 0, len = matches.length; j < len; j++) {
        match = matches[j];
        doomed = doomed && match.doomed;
      }
      return !doomed;
    };

    Cell.prototype.flagCleared = function() {
      var j, l, len, len1, m, ref, ref1;
      if (this.horizontalMatches().length >= 3 && this.hasSomeHope(this.horizontalMatches())) {
        GEMCRUSHER.score.add(this.horizontalMatches().length, this.x, this.y);
        ref = this.horizontalMatches();
        for (j = 0, len = ref.length; j < len; j++) {
          m = ref[j];
          m.doomed = true;
        }
      }
      if (this.verticalMatches().length >= 3 && this.hasSomeHope(this.verticalMatches())) {
        GEMCRUSHER.score.add(this.verticalMatches().length, this.x, this.y);
        ref1 = this.verticalMatches();
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          m = ref1[l];
          m.doomed = true;
        }
      }
      return this.dirty = false;
    };

    Cell.prototype.swapGems = function(cell) {
      this.new_gem = cell.gem;
      cell.new_gem = this.gem;
      if (this.willClear() || cell.willClear()) {
        this.new_gem.doSwap(this.xPos(), this.yPos(), true, false);
        cell.new_gem.doSwap(cell.xPos(), cell.yPos(), true, true);
        this.commitNew();
        cell.commitNew();
        this.flagCleared();
        return cell.flagCleared();
      } else {
        this.new_gem.doSwap(this.xPos(), this.yPos(), false, false);
        cell.new_gem.doSwap(cell.xPos(), cell.yPos(), false, true);
        this.new_gem = null;
        return cell.new_gem = null;
      }
    };

    Cell.prototype.matchGem = function() {
      return this.new_gem || this.gem;
    };

    Cell.prototype.horizontalMatches = function() {
      return [this.matchGem()].concat(this.match(this.matchGem().def_id, 'left')).concat(this.match(this.matchGem().def_id, 'right'));
    };

    Cell.prototype.verticalMatches = function() {
      return [this.matchGem()].concat(this.match(this.matchGem().def_id, 'up')).concat(this.match(this.matchGem().def_id, 'down'));
    };

    Cell.prototype.willClear = function() {
      return this.horizontalMatches().length >= 3 || this.verticalMatches().length >= 3;
    };

    Cell.prototype.match = function(def_id, dir) {
      var cell, ref;
      cell = (function() {
        var ref, ref1, ref2, ref3;
        switch (dir) {
          case 'left':
            return (ref = GEMCRUSHER.grid.cells[this.x - 1]) != null ? ref[this.y] : void 0;
          case 'right':
            return (ref1 = GEMCRUSHER.grid.cells[this.x + 1]) != null ? ref1[this.y] : void 0;
          case 'up':
            return (ref2 = GEMCRUSHER.grid.cells[this.x]) != null ? ref2[this.y + 1] : void 0;
          case 'down':
            return (ref3 = GEMCRUSHER.grid.cells[this.x]) != null ? ref3[this.y - 1] : void 0;
        }
      }).call(this);
      if (!cell) {
        return [];
      }
      if (((ref = cell.matchGem()) != null ? ref.def_id : void 0) === def_id) {
        return [cell.matchGem()].concat(cell.match(def_id, dir));
      } else {
        return [];
      }
    };

    Cell.prototype.squareOpacity = function() {
      if (this.y % 2 !== this.x % 2) {
        return 0.2;
      } else {
        return 0.5;
      }
    };

    Cell.prototype.squareAxis = function() {
      if (this.y % 2 !== this.x % 2) {
        return 'x';
      } else {
        return 'y';
      }
    };

    Cell.prototype.hide = function() {
      return this.animate(0, Math.PI / 2);
    };

    Cell.prototype.show = function() {
      return this.animate(Math.PI / 2, 0);
    };

    Cell.prototype.animate = function(startR, endR) {
      var show_tween;
      this.tween_data = {
        r: startR
      };
      show_tween = new TWEEN.Tween(this.tween_data).to({
        r: endR
      }, 1000).easing(TWEEN.Easing.Quartic.In).onUpdate(this.tweenTick);
      return show_tween.start();
    };

    Cell.prototype.tweenTick = function() {
      return this.square.rotation[this.squareAxis()] = this.tween_data.r;
    };

    Cell.prototype.buildSquare = function() {
      var geom, mat;
      mat = new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: this.squareOpacity(),
        color: 'gray'
      });
      geom = new THREE.PlaneBufferGeometry(1, 1);
      this.square = new THREE.Mesh(geom, mat);
      this.square.position.x = this.xPos();
      this.square.position.y = this.yPos();
      return this.square.rotation[this.squareAxis()] = Math.PI / 2;
    };

    Cell.prototype.highlite = function(t) {
      var ref;
      return (ref = this.gem) != null ? ref.highlite(t) : void 0;
    };

    Cell.prototype.reset = function() {
      var ref;
      return (ref = this.gem) != null ? ref.reset() : void 0;
    };

    return Cell;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Cell = Cell;

  Fps = (function() {
    function Fps() {
      this.refresh = 1000;
      this.frames = 0;
      this.lasttime = 0;
    }

    Fps.prototype.timeDiff = function(t) {
      return t - this.lasttime;
    };

    Fps.prototype.update = function(t) {
      var fps;
      this.frames++;
      if (this.timeDiff(t) > this.refresh) {
        fps = Math.floor(this.frames / (this.timeDiff(t) / 100000)) / 100;
        document.getElementById('fps').innerText = "fps: " + fps;
        this.frames = 0;
        return this.lasttime = t;
      }
    };

    return Fps;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Fps = Fps;

  GemCascade = (function() {
    function GemCascade(count) {
      this.count = count;
      this.minimum_falltime = 3000;
      this.maximum_falltime = 8000;
      this.object = new THREE.Object3D();
      this.object.scale.multiplyScalar(this.scale());
      this.gems = this.buildGems();
      this.run = false;
      GEMCRUSHER.addEventListener('resize', this.resize);
    }

    GemCascade.prototype.scale = function() {
      return GEMCRUSHER.base_width / GEMCRUSHER.grid_width;
    };

    GemCascade.prototype.buildGems = function() {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = this.count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.buildGem());
      }
      return results;
    };

    GemCascade.prototype.buildGem = function() {
      var gem;
      gem = GEMCRUSHER.gem_factory.random();
      gem.setY(GEMCRUSHER.height() / GEMCRUSHER.width() * 9);
      gem.addEventListener('animationcomplete', (function(_this) {
        return function() {
          return _this.dropLoop(gem);
        };
      })(this));
      return gem;
    };

    GemCascade.prototype.dropLoop = function(gem, delay) {
      if (delay == null) {
        delay = false;
      }
      if (this.run) {
        return this.animate(gem, delay);
      } else {
        return this.object.remove(gem.object);
      }
    };

    GemCascade.prototype.animate = function(gem, delay) {
      var scale, time;
      if (delay == null) {
        delay = false;
      }
      scale = Math.random();
      time = this.minimum_falltime + (this.maximum_falltime - this.minimum_falltime) * (1 - scale);
      delay = delay ? delay : 1000 * Math.random();
      gem.setX(8 * Math.random());
      gem.setY(GEMCRUSHER.height() / GEMCRUSHER.width() * 9);
      gem.object.rotation.set(Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random());
      gem.object.scale.set(scale * 1.5 + 0.2, scale * 1.5 + 0.2, scale * 1.5 + 0.2);
      return gem.tumbleTo(-1, delay, scale * 20 - 30, time);
    };

    GemCascade.prototype.start = function() {
      var gem, i, j, len, ref;
      if (this.run) {
        return;
      }
      this.run = true;
      ref = this.gems;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        gem = ref[i];
        this.object.add(gem.object);
        this.dropLoop(gem, i * (this.maximum_falltime / this.gems.length));
      }
      return this.object.visible = true;
    };

    GemCascade.prototype.stop = function() {
      this.object.visible = false;
      return this.run = false;
    };

    return GemCascade;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.GemCascade = GemCascade;

  GemFactory = (function() {
    function GemFactory() {
      this.gemsLoaded = bind(this.gemsLoaded, this);
      this.loaded = false;
      this.jsonloader = new THREE.JSONLoader();
      this.scalefactor = 1.125;
      this.outline = new THREE.MeshBasicMaterial({
        color: 'black',
        side: THREE.BackSide
      });
      this.gemid = 0;
      this.loadGems();
    }

    GemFactory.prototype.loadGems = function() {
      this.req = new XMLHttpRequest();
      this.req.onload = this.gemsLoaded;
      this.req.open("GET", 'models/gems.json');
      return this.req.send();
    };

    GemFactory.prototype.gemsLoaded = function() {
      var chunk, gem, i, json;
      json = JSON.parse(this.req.responseText);
      chunk = this.buildGeometry(json.chunk.geometry, this.scalefactor / 2);
      this.defs = (function() {
        var j, len, ref, results;
        ref = json.gems;
        results = [];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          gem = ref[i];
          results.push({
            id: i,
            geometry: this.buildGeometry(gem.geometry, this.scalefactor),
            material: this.buildMaterial(gem.color),
            outline: this.outline,
            chunk: chunk
          });
        }
        return results;
      }).call(this);
      this.loaded = true;
      return this.onload();
    };

    GemFactory.prototype.buildGeometry = function(def, scale) {
      var geom, r, rx, s;
      geom = this.jsonloader.parse(def).geometry;
      rx = new THREE.Matrix4().makeRotationX(Math.PI / 2);
      s = new THREE.Matrix4().makeScale(scale, scale * 1.3, scale);
      r = new THREE.Matrix4().multiplyMatrices(rx, s);
      geom.applyMatrix(r);
      return new THREE.BufferGeometry().fromGeometry(geom);
    };

    GemFactory.prototype.buildMaterial = function(color) {
      return new THREE.MeshPhongMaterial({
        color: color,
        ambient: color,
        shininess: 60
      });
    };

    GemFactory.prototype.buildGem = function(def) {
      return new GemCrusher.Gem(def, this.gemid++);
    };

    GemFactory.prototype.random = function() {
      return this.buildGem(this.defs[Math.floor(Math.random() * this.defs.length)]);
    };

    GemFactory.prototype.onload = function() {};

    return GemFactory;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.GemFactory = GemFactory;

  Gem = (function(superClass) {
    extend(Gem, superClass);

    function Gem(def, id) {
      this.tweenTick = bind(this.tweenTick, this);
      this.tumbleTweenTick = bind(this.tumbleTweenTick, this);
      this.shakeTweenTick = bind(this.shakeTweenTick, this);
      this.shakeDone = bind(this.shakeDone, this);
      this.animationComplete = bind(this.animationComplete, this);
      this.hurlTweenComplete = bind(this.hurlTweenComplete, this);
      this.hurlTweenTick = bind(this.hurlTweenTick, this);
      this.hurlStart = bind(this.hurlStart, this);
      var i;
      this.id = id;
      this.def = def;
      this.def_id = def.id;
      this.object = new THREE.Object3D();
      this.mesh = new THREE.Mesh(def.geometry, def.material);
      this.outline = new THREE.Mesh(def.geometry, def.outline);
      this.chunks = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 3; i = ++j) {
          results.push(this.buildChunk());
        }
        return results;
      }).call(this);
      this.outline.scale.multiplyScalar(1.125);
      this.outline.position.z = -0.05;
      this.animating = false;
      this.object.add(this.mesh);
      this.object.add(this.outline);
      this.swap_length = 400;
    }

    Gem.prototype.setX = function(x) {
      return this.object.position.x = x;
    };

    Gem.prototype.setY = function(y) {
      return this.object.position.y = y;
    };

    Gem.prototype.buildChunk = function() {
      var mesh, object, outline;
      object = new THREE.Object3D();
      mesh = new THREE.Mesh(this.def.chunk, this.def.material);
      outline = new THREE.Mesh(this.def.chunk, this.def.outline);
      outline.scale.multiplyScalar(1.125);
      object.add(mesh);
      object.add(outline);
      object.rotation.set(Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random());
      object.position.z = -1;
      object.visible = false;
      this.object.add(object);
      return object;
    };

    Gem.prototype.explode = function(delay) {
      var chunk, j, len, ref;
      if (delay == null) {
        delay = 0;
      }
      ref = this.chunks;
      for (j = 0, len = ref.length; j < len; j++) {
        chunk = ref[j];
        chunk.visible = true;
      }
      return this.hurlChunks(delay);
    };

    Gem.prototype.show = function() {
      this.mesh.visible = true;
      return this.outline.visible = true;
    };

    Gem.prototype.hide = function() {
      this.mesh.visible = false;
      return this.outline.visible = false;
    };

    Gem.prototype.hurlStart = function() {
      var chunk, j, len, ref;
      this.hide();
      ref = this.chunks;
      for (j = 0, len = ref.length; j < len; j++) {
        chunk = ref[j];
        chunk.position.z = 1;
      }
      return GEMCRUSHER.audio.play('pop');
    };

    Gem.prototype.hurlChunks = function(delay) {
      var chunk, d, hurl_tween, th;
      this.hurl_tween = {
        x0: this.chunks[0].position.x,
        y0: this.chunks[0].position.y,
        x1: this.chunks[1].position.x,
        y1: this.chunks[1].position.y,
        x2: this.chunks[2].position.x,
        y2: this.chunks[2].position.y,
        x3: this.chunks[3].position.x,
        y3: this.chunks[3].position.y,
        s: 1
      };
      d = (function() {
        var j, len, ref, results;
        ref = this.chunks;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          chunk = ref[j];
          results.push(this.randomDest());
        }
        return results;
      }).call(this);
      th = {
        x0: d[0].x,
        y0: d[0].y,
        x1: d[1].x,
        y1: d[1].y,
        x2: d[2].x,
        y2: d[2].y,
        x3: d[3].x,
        y3: d[3].y,
        s: 6
      };
      hurl_tween = new TWEEN.Tween(this.hurl_tween).to(th, 1500).easing(TWEEN.Easing.Linear.None).onStart(this.hurlStart).onUpdate(this.hurlTweenTick).onComplete(this.hurlTweenComplete).delay(delay);
      return hurl_tween.start();
    };

    Gem.prototype.randomDest = function() {
      var ra, rx, ry;
      ra = Math.PI * 2 * Math.random();
      rx = Math.sin(ra) * GEMCRUSHER.grid_height * (1 + Math.random());
      ry = Math.cos(ra) * GEMCRUSHER.grid_height * (1 + Math.random());
      return {
        x: rx,
        y: ry
      };
    };

    Gem.prototype.hurlTweenTick = function() {
      var i, j, results;
      results = [];
      for (i = j = 0; j <= 3; i = ++j) {
        this.chunks[i].rotation.x += this.hurl_tween["x" + i] - this.chunks[i].position.x;
        this.chunks[i].rotation.y += this.hurl_tween["y" + i] - this.chunks[i].position.y;
        this.chunks[i].position.x = this.hurl_tween["x" + i];
        this.chunks[i].position.y = this.hurl_tween["y" + i];
        this.chunks[i].scale.x = this.hurl_tween.s;
        this.chunks[i].scale.y = this.hurl_tween.s;
        results.push(this.chunks[i].scale.z = this.hurl_tween.s);
      }
      return results;
    };

    Gem.prototype.hurlTweenComplete = function() {
      return this.removeGem();
    };

    Gem.prototype.removeGem = function() {
      return this.object.parent.remove(this.object);
    };

    Gem.prototype.animationComplete = function() {
      this.object.position.z = 0;
      if (this.shake_data) {
        this.updateShakeOrigin();
      }
      this.animating = false;
      return this.dispatchEvent({
        type: 'animationcomplete'
      });
    };

    Gem.prototype.randomAngle = function() {
      return Math.random() * Math.PI * 2;
    };

    Gem.prototype.shake = function() {
      if (this.shake_data) {
        return;
      }
      this.shake_data = {
        original_x: this.object.position.x,
        original_y: this.object.position.y,
        x: this.object.position.x,
        y: this.object.position.y
      };
      return this.doShake();
    };

    Gem.prototype.updateShakeOrigin = function() {
      this.shake_tween.stop();
      this.shake_data = null;
      return this.shake();
    };

    Gem.prototype.doShake = function() {
      var a, to;
      a = this.randomAngle();
      to = {
        x: this.shake_data.original_x + Math.cos(a) / 32,
        y: this.shake_data.original_y + Math.sin(a) / 32
      };
      this.shake_tween = new TWEEN.Tween(this.shake_data).to(to, 50).easing(TWEEN.Easing.Linear.None).onComplete(this.shakeDone).onUpdate(this.shakeTweenTick);
      return this.shake_tween.start();
    };

    Gem.prototype.shakeDone = function() {
      return this.doShake();
    };

    Gem.prototype.shakeTweenTick = function() {
      if (this.animating) {
        return;
      }
      this.object.position.x = this.shake_data.x;
      return this.object.position.y = this.shake_data.y;
    };

    Gem.prototype.dropToDoom = function() {
      this.addEventListener('animationcomplete', this.hide);
      this.object.position.z = -5;
      return this.dropTo(-5, Math.random() * 1000, 0);
    };

    Gem.prototype.dropTo = function(y, delay, z, length) {
      var drop_tween;
      if (length == null) {
        length = 1250;
      }
      this.animating = true;
      this.tween_data = {
        x: this.object.position.x,
        y: this.object.position.y,
        s: 1,
        z: z
      };
      drop_tween = new TWEEN.Tween(this.tween_data).to({
        y: y
      }, length).easing(TWEEN.Easing.Bounce.Out).onUpdate(this.tweenTick);
      return drop_tween.onComplete(this.animationComplete).delay(delay).start();
    };

    Gem.prototype.tumbleTo = function(y, delay, z, length) {
      var drop_tween;
      if (length == null) {
        length = 1250;
      }
      this.animating = true;
      this.object.position.z = z;
      this.tumble_data = {
        y: this.object.position.y
      };
      drop_tween = new TWEEN.Tween(this.tumble_data).to({
        y: y
      }, length).easing(TWEEN.Easing.Linear.None).onUpdate(this.tumbleTweenTick);
      return drop_tween.onComplete(this.animationComplete).delay(delay).start();
    };

    Gem.prototype.tumbleTweenTick = function() {
      this.object.position.y = this.tumble_data.y;
      this.object.rotation.x += 0.01;
      this.object.rotation.y += 0.01;
      return this.object.rotation.z += 0.01;
    };

    Gem.prototype.doSwap = function(x, y, real, front) {
      if (real == null) {
        real = true;
      }
      if (front == null) {
        front = true;
      }
      this.animating = true;
      this.tween_data = {
        x: this.object.position.x,
        y: this.object.position.y,
        s: 1,
        z: 0
      };
      if (real) {
        this.zoomTween(front).start();
        return this.realSwapTween(x, y).start();
      } else {
        this.failedZoomTween(front).start();
        return this.failedSwapTween(x, y).start();
      }
    };

    Gem.prototype.swapStart = function() {
      return GEMCRUSHER.audio.play('woosh');
    };

    Gem.prototype.zoomTween = function(front) {
      var sc, zoom_tween_end, zoom_tween_start;
      if (front == null) {
        front = true;
      }
      sc = front ? 1.5 : 0.5;
      zoom_tween_start = new TWEEN.Tween(this.tween_data).to({
        s: sc,
        z: sc - 1
      }, this.swap_length / 2).easing(TWEEN.Easing.Circular.Out).onUpdate(this.tweenTick);
      zoom_tween_end = new TWEEN.Tween(this.tween_data).to({
        s: 1,
        z: 0
      }, this.swap_length / 2).easing(TWEEN.Easing.Circular.In).onUpdate(this.tweenTick);
      return zoom_tween_start.chain(zoom_tween_end);
    };

    Gem.prototype.realSwapTween = function(x, y) {
      return new TWEEN.Tween(this.tween_data).to({
        x: x,
        y: y
      }, this.swap_length).easing(TWEEN.Easing.Back.InOut).onUpdate(this.tweenTick).onStart(this.swapStart).onComplete(this.animationComplete);
    };

    Gem.prototype.failedSwapTween = function(x, y) {
      var swap_end, swap_start;
      swap_start = new TWEEN.Tween(this.tween_data).to({
        x: x,
        y: y
      }, this.swap_length / 1.5).easing(TWEEN.Easing.Back.In).onStart(this.swapStart).onUpdate(this.tweenTick);
      swap_end = new TWEEN.Tween(this.tween_data).to({
        x: this.object.position.x,
        y: this.object.position.y
      }, this.swap_length / 1.5).easing(TWEEN.Easing.Quadratic.InOut).onStart(this.swapStart).onUpdate(this.tweenTick).onComplete(this.animationComplete);
      return swap_start.chain(swap_end);
    };

    Gem.prototype.failedZoomTween = function(front) {
      var a, b, c, d, sc;
      if (front == null) {
        front = true;
      }
      sc = front ? 1.5 : 0.5;
      a = new TWEEN.Tween(this.tween_data).to({
        s: sc,
        z: sc - 1
      }, this.swap_length / 3).easing(TWEEN.Easing.Circular.Out).onUpdate(this.tweenTick);
      b = new TWEEN.Tween(this.tween_data).to({
        s: 1,
        z: 0
      }, this.swap_length / 3).easing(TWEEN.Easing.Circular.In).onUpdate(this.tweenTick);
      c = new TWEEN.Tween(this.tween_data).to({
        s: 2 - sc,
        z: 1 - sc
      }, this.swap_length / 3).easing(TWEEN.Easing.Circular.In).onUpdate(this.tweenTick);
      d = new TWEEN.Tween(this.tween_data).to({
        s: 1,
        z: 0
      }, this.swap_length / 3).easing(TWEEN.Easing.Circular.Out).onUpdate(this.tweenTick);
      c.chain(d);
      b.chain(c);
      return a.chain(b);
    };

    Gem.prototype.flyAway = function() {
      var a, dist, fly_time, fly_tween, fly_tween2, mult, spinx, spiny, to, vx, vy;
      this.animating = true;
      fly_time = 2000;
      vx = this.object.position.x - 4;
      vy = this.object.position.y - 4;
      spiny = Math.abs(vx) / vx;
      spinx = Math.abs(vy) / vy;
      dist = Math.sqrt(Math.pow(Math.abs(vx), 2) + Math.pow(Math.abs(vy), 2));
      a = Math.atan2(vx, vy);
      mult = dist / 5;
      this.tween_data = {
        x: this.object.position.x,
        y: this.object.position.y,
        s: 1,
        z: 0,
        spin: 0,
        spiny: spiny,
        spinx: spinx
      };
      to = {
        x: this.object.position.x + Math.sin(a) * GEMCRUSHER.grid_height * 1.5,
        y: this.object.position.y + Math.cos(a) * GEMCRUSHER.grid_height * 1.5
      };
      fly_tween = new TWEEN.Tween(this.tween_data).to(to, fly_time).easing(TWEEN.Easing.Back.In).onUpdate(this.tweenTick).onComplete(this.animationComplete);
      fly_tween2 = new TWEEN.Tween(this.tween_data).to({
        s: 2,
        spin: 5
      }, fly_time).easing(TWEEN.Easing.Linear.None);
      fly_tween2.delay(mult * 4000).start();
      return fly_tween.delay(mult * 4000).start();
    };

    Gem.prototype.tweenTick = function() {
      this.object.position.x = this.tween_data.x;
      this.object.position.y = this.tween_data.y;
      this.object.position.z = this.tween_data.z;
      this.object.scale.x = this.tween_data.s;
      this.object.scale.y = this.tween_data.s;
      if (this.tween_data.spin) {
        this.object.rotation.z = this.tween_data.spin * this.tween_data.spinx * this.tween_data.spiny;
        this.object.rotation.x = -this.tween_data.spin * this.tween_data.spinx;
        return this.object.rotation.y = this.tween_data.spin * this.tween_data.spiny;
      }
    };

    Gem.prototype.highlite = function(t) {
      this.object.rotation.z = Math.PI * 2 - t / 400 % Math.PI * 2;
      this.object.scale.x = 1.25;
      return this.object.scale.y = 1.25;
    };

    Gem.prototype.reset = function() {
      this.object.rotation.z = 0;
      this.object.scale.x = 1;
      return this.object.scale.y = 1;
    };

    return Gem;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Gem = Gem;

  Grid = (function(superClass) {
    extend(Grid, superClass);

    function Grid(w, h) {
      this.levelComplete = bind(this.levelComplete, this);
      this.flyAway = bind(this.flyAway, this);
      this.gemsDropped = bind(this.gemsDropped, this);
      this.animationComplete = bind(this.animationComplete, this);
      this.w = w;
      this.h = h;
      this.margin = 0;
      this.footer = 1;
      this.cells = this.buildCells();
      this.object = new THREE.Object3D();
      this.ready_for_input = true;
      this.board = this.buildBoard();
      this.object.add(this.board);
      this.object.position.x = this.scale(this.margin);
      this.object.position.y = this.scale(this.margin + this.footer);
      this.object.scale.multiplyScalar(this.scale());
    }

    Grid.prototype.scale = function(i) {
      if (i == null) {
        i = 1;
      }
      return GEMCRUSHER.base_width / this.w * i;
    };

    Grid.prototype.flatCells = function() {
      return Array.prototype.concat.apply([], this.cells);
    };

    Grid.prototype.doomedCells = function() {
      var cell, j, len, ref, ref1, ref2, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        if (((ref1 = cell.gem) != null ? ref1.doomed : void 0) && ((ref2 = cell.gem) != null ? ref2.exploding : void 0) !== true) {
          results.push(cell);
        }
      }
      return results;
    };

    Grid.prototype.emptyCells = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        if (cell.gem === null) {
          results.push(cell);
        }
      }
      return results;
    };

    Grid.prototype.dirtyCells = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        if (cell.dirty) {
          results.push(cell);
        }
      }
      return results;
    };

    Grid.prototype.animating = function() {
      var cell, j, len, ref, ref1;
      ref = this.flatCells();
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        if ((ref1 = cell.gem) != null ? ref1.animating : void 0) {
          return true;
        }
      }
      return false;
    };

    Grid.prototype.clearDoomed = function() {
      var cell, i, j, len, ref, results;
      ref = this.doomedCells();
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        cell = ref[i];
        cell.gem.explode(i * 50);
        results.push(cell.gem = null);
      }
      return results;
    };

    Grid.prototype.checkDirty = function() {
      var cell, j, len, ref, results;
      ref = this.dirtyCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(cell.flagCleared());
      }
      return results;
    };

    Grid.prototype.fillHoles = function() {
      var cell, j, len, ref, results;
      ref = this.emptyCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(this.fillCell(cell));
      }
      return results;
    };

    Grid.prototype.fillCell = function(cell) {
      var j, new_cell, ref, ref1, results, y;
      cell.dirty = true;
      results = [];
      for (y = j = ref = cell.y + 1, ref1 = this.h; ref <= ref1 ? j <= ref1 : j >= ref1; y = ref <= ref1 ? ++j : --j) {
        if (y === this.h) {
          cell.gem = GEMCRUSHER.gem_factory.random();
          cell.gem.setX(cell.xPos());
          cell.gem.setY(this.h * 2);
          cell.gem.addEventListener('animationcomplete', this.animationComplete);
          this.object.add(cell.gem.object);
          cell.gem.show();
          results.push(cell.gem.dropTo(cell.yPos(), 0, 0, 500));
        } else {
          new_cell = this.cells[cell.x][y];
          if (new_cell.gem) {
            cell.gem = new_cell.gem;
            new_cell.gem = null;
            cell.gem.dropTo(cell.yPos(), 0, 0, 500);
            this.fillCell(new_cell);
            break;
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };

    Grid.prototype.update = function(t) {
      var current, ref;
      if (this.animating() || this.end) {
        return;
      }
      this.clearDoomed();
      while (this.emptyCells().length > 0) {
        this.fillHoles();
      }
      if (this.dirtyCells().length > 0) {
        this.checkDirty();
      } else {
        GEMCRUSHER.score.chain = 0;
      }
      if (this.ready_for_input && GEMCRUSHER.input.touching) {
        this.selected = this.touchedCell(GEMCRUSHER.input.start);
        current = this.touchedCell(GEMCRUSHER.input.move);
        if (!this.validMove(this.selected, current)) {
          return this.stopInput();
        }
        if (this.selected === current) {
          if ((ref = this.selected) != null) {
            ref.highlite(t);
          }
        } else {
          this.stopInput();
          this.selected.swapGems(current);
        }
      }
      if (!GEMCRUSHER.input.touching && !this.animating()) {
        if (this.selected) {
          this.selected.reset();
          this.selected = null;
        }
        return this.ready_for_input = true;
      }
    };

    Grid.prototype.validMove = function(cell1, cell2) {
      return cell1 && cell1.gem && cell2 && cell2.gem && (Math.abs(cell1.x - cell2.x) + Math.abs(cell1.y - cell2.y)) <= 1;
    };

    Grid.prototype.stopInput = function() {
      var ref;
      this.ready_for_input = false;
      return (ref = this.selected) != null ? ref.reset() : void 0;
    };

    Grid.prototype.bottomOffset = function() {
      return this.scale(this.footer);
    };

    Grid.prototype.touchedCell = function(pos) {
      var ref, x, y;
      x = Math.floor(pos.x / this.scale() - this.margin);
      y = Math.floor((pos.y - this.bottomOffset()) / this.scale());
      return (ref = this.cells[x]) != null ? ref[y] : void 0;
    };

    Grid.prototype.clear = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        this.object.remove(cell.gem.object);
        results.push(cell.gem = null);
      }
      return results;
    };

    Grid.prototype.addGems = function() {
      var cell, j, len, ref, results, row;
      this.ready = false;
      this.end = false;
      ref = this.cells;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        results.push((function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = row.length; l < len1; l++) {
            cell = row[l];
            while (true) {
              cell.gem = GEMCRUSHER.gem_factory.random();
              if (!cell.willClear()) {
                break;
              }
            }
            cell.gem.setX(cell.xPos());
            cell.gem.setY(this.h * 2);
            cell.gem.addEventListener('animationcomplete', this.animationComplete);
            this.object.add(cell.gem.object);
            cell.gem.show();
            results1.push(cell.gem.dropTo(cell.yPos(), 1000 + cell.yPos() * 50 + cell.xPos() * 10, -cell.yPos()));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Grid.prototype.buildBoard = function() {
      var board, cell, j, len, ref;
      board = new THREE.Object3D();
      board.position.z = -20 * this.h;
      ref = this.flatCells();
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        board.add(cell.square);
      }
      return board;
    };

    Grid.prototype.animationComplete = function() {
      if (this.animating()) {
        return;
      }
      if (!this.ready && !this.end) {
        this.ready = true;
        this.dispatchEvent({
          type: 'ready'
        });
      }
      return this.dispatchEvent({
        type: 'animationcomplete'
      });
    };

    Grid.prototype.buildCells = function() {
      var j, ref, results, x, y;
      results = [];
      for (x = j = 0, ref = this.h; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (y = l = 0, ref1 = this.w; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
            results1.push(new GemCrusher.Cell(x, y));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Grid.prototype.show = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(cell.show());
      }
      return results;
    };

    Grid.prototype.hide = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(cell.hide());
      }
      return results;
    };

    Grid.prototype.dropGems = function() {
      var cell, j, len, ref;
      this.end = true;
      ref = this.flatCells();
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        cell.gem.dropToDoom();
      }
      return this.addEventListener('animationcomplete', this.gemsDropped);
    };

    Grid.prototype.gemsDropped = function() {
      this.removeEventListener('animationcomplete', this.gemsDropped);
      return this.dispatchEvent({
        type: 'gemsdropped'
      });
    };

    Grid.prototype.complete = function() {
      return this.addEventListener('animationcomplete', this.flyAway);
    };

    Grid.prototype.flyAway = function() {
      var cell, j, len, ref;
      this.removeEventListener('animationcomplete', this.flyAway);
      ref = this.flatCells();
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        cell.gem.flyAway();
      }
      return this.addEventListener('animationcomplete', this.levelComplete);
    };

    Grid.prototype.levelComplete = function() {
      this.clear();
      this.removeEventListener('animationcomplete', this.levelComplete);
      return this.dispatchEvent({
        type: 'levelcomplete'
      });
    };

    Grid.prototype.shakeGems = function() {
      var cell, j, len, ref, results;
      ref = this.flatCells();
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        cell = ref[j];
        results.push(cell.gem.shake());
      }
      return results;
    };

    return Grid;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Grid = Grid;

  window.GEMCRUSHER = null;

  init = function() {
    window.GEMCRUSHER = new GemCrusher.Main();
    return window.GEMCRUSHER.init();
  };

  document.addEventListener('deviceready', init);

  if (typeof jQuery !== "undefined" && jQuery !== null) {
    jQuery(init);
  }

  Input = (function(superClass) {
    extend(Input, superClass);

    function Input() {
      this.updateOrientation = bind(this.updateOrientation, this);
      this.touchMove = bind(this.touchMove, this);
      this.touchEnd = bind(this.touchEnd, this);
      this.touchStart = bind(this.touchStart, this);
      this.mouseUp = bind(this.mouseUp, this);
      this.mouseMove = bind(this.mouseMove, this);
      this.mouseDown = bind(this.mouseDown, this);
      this.touching = false;
      this.bindEvents();
      this.start = {
        x: null,
        y: null
      };
      this.move = {
        x: null,
        y: null
      };
      this.orientation = {
        alpha: 0,
        beta: 0,
        gamma: 0
      };
      this.scale_factor = 1;
    }

    Input.prototype.bindEvents = function() {
      window.addEventListener('mousedown', this.mouseDown);
      window.addEventListener('mousemove', this.mouseMove);
      window.addEventListener('mouseup', this.mouseUp);
      window.addEventListener('touchstart', this.touchStart);
      window.addEventListener('touchend', this.touchEnd);
      window.addEventListener('touchmove', this.touchMove);
      return window.addEventListener('deviceorientation', this.updateOrientation);
    };

    Input.prototype.mouseDown = function(e) {
      if (e.buttons === 1) {
        return this.startEvent(e.clientX, e.clientY);
      }
    };

    Input.prototype.mouseMove = function(e) {
      if (e.buttons === 1) {
        return this.moveEvent(e.clientX, e.clientY);
      }
    };

    Input.prototype.mouseUp = function(e) {
      if (e.buttons === 1) {
        return this.endEvent();
      }
    };

    Input.prototype.touchStart = function(e) {
      return this.startEvent(this.touchX(e), this.touchY(e));
    };

    Input.prototype.startEvent = function(x, y) {
      this.touching = true;
      this.start.x = this.scale(x);
      this.start.y = this.scale(this.realHeight() - y);
      this.move = {
        x: this.start.x,
        y: this.start.y
      };
      return this.dispatchEvent({
        type: 'touchstart',
        x: this.start.x,
        y: this.start.y
      });
    };

    Input.prototype.touchEnd = function(e) {
      return this.endEvent();
    };

    Input.prototype.endEvent = function() {
      this.touching = false;
      return this.dispatchEvent({
        type: 'touchend'
      });
    };

    Input.prototype.touchMove = function(e) {
      return this.moveEvent(this.touchX(e), this.touchY(e));
    };

    Input.prototype.moveEvent = function(x, y) {
      this.move.x = this.scale(x);
      this.move.y = this.scale(this.realHeight() - y);
      return this.dispatchEvent({
        type: 'touchmove',
        x: this.move.x,
        y: this.move.y
      });
    };

    Input.prototype.updateOrientation = function(orientation) {
      this.orientation.alpha = orientation.alpha || 0;
      this.orientation.gamma = orientation.gamma || 0;
      return this.orientation.beta = orientation.beta || 0;
    };

    Input.prototype.touchX = function(e) {
      return e.touches[0].screenX * window.devicePixelRatio;
    };

    Input.prototype.touchY = function(e) {
      return e.touches[0].screenY * window.devicePixelRatio;
    };

    Input.prototype.realHeight = function() {
      return window.innerHeight * window.devicePixelRatio;
    };

    Input.prototype.scale = function(i) {
      return i * this.scale_factor;
    };

    return Input;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Input = Input;

  Logger = (function() {
    function Logger(enabled) {
      if (enabled == null) {
        enabled = true;
      }
      this.enabled = enabled;
      this.loglines = [];
    }

    Logger.prototype.log = function(text) {
      if (!this.enabled) {
        return;
      }
      this.loglines.push(text);
      return document.getElementById('log').innerText = this.loglines.join("\n");
    };

    return Logger;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Logger = Logger;

  Main = (function(superClass) {
    extend(Main, superClass);

    function Main() {
      this.gameOver = bind(this.gameOver, this);
      this.goalReached = bind(this.goalReached, this);
      this.nextLevel = bind(this.nextLevel, this);
      this.gridReady = bind(this.gridReady, this);
      this.renderLoop = bind(this.renderLoop, this);
      this.closeAbout = bind(this.closeAbout, this);
      this.gemsLoaded = bind(this.gemsLoaded, this);
      this.resize = bind(this.resize, this);
      this.grid_width = 8;
      this.grid_height = 8;
      this.base_width = 1000;
      document.getElementById('closebutton').addEventListener('touchstart', this.closeAbout);
      document.getElementById('closebutton').addEventListener('click', this.closeAbout);
    }

    Main.prototype.init = function() {
      this.initThree();
      this.input = new GemCrusher.Input();
      this.input.scale_factor = 1 / (this.width() / 1000);
      this.score = new GemCrusher.Score();
      this.score.addEventListener('goalreached', this.goalReached);
      this.gem_factory = new GemCrusher.GemFactory();
      this.audio = new GemCrusher.AudioManager(['sounds/woosh.mp3', 'sounds/pop.mp3']);
      this.roaming_light = new GemCrusher.RoamingLight(this.base_width);
      this.grid = new GemCrusher.Grid(this.grid_width, this.grid_height, this);
      this.grid.addEventListener('ready', this.gridReady);
      this.grid.addEventListener('levelcomplete', this.nextLevel);
      this.grid.addEventListener('gemsdropped', this.gameOver);
      this.menu = new GemCrusher.Menu();
      this.background = new GemCrusher.Background();
      this.background.scale(1 / this.aspect());
      this.progress_meter = new GemCrusher.ProgressMeter();
      this.timer = new GemCrusher.Timer();
      this.timer.addEventListener('danger', (function(_this) {
        return function() {
          return _this.timeDanger();
        };
      })(this));
      this.timer.addEventListener('end', (function(_this) {
        return function() {
          return _this.timesUp();
        };
      })(this));
      this.score_board = new GemCrusher.ScoreBoard();
      this.multiplier_display = new GemCrusher.MultiplierDisplay();
      this.scene.add(this.multiplier_display.object);
      this.scene.add(this.score_board.object);
      this.scene.add(this.timer.object);
      this.scene.add(this.progress_meter.object);
      this.scene.add(this.menu.object);
      this.scene.add(this.roaming_light.object);
      this.scene.add(this.background.object);
      this.scene.add(this.grid.object);
      this.scene.scale.x = this.scale();
      this.scene.scale.y = this.scale();
      GEMCRUSHER.gem_factory.onload = this.gemsLoaded;
      return this.renderLoop(0);
    };

    Main.prototype.aspect = function() {
      return this.width() / this.height();
    };

    Main.prototype.scale = function() {
      return this.width() / this.base_width;
    };

    Main.prototype.width = function() {
      if (this.realAspect() > 0.7) {
        return this.realHeight() * 0.7;
      } else {
        return this.realWidth();
      }
    };

    Main.prototype.height = function() {
      return this.realHeight();
    };

    Main.prototype.realWidth = function() {
      return window.innerWidth * window.devicePixelRatio;
    };

    Main.prototype.realHeight = function() {
      return window.innerHeight * window.devicePixelRatio;
    };

    Main.prototype.realAspect = function() {
      return window.innerWidth / window.innerHeight;
    };

    Main.prototype.initThree = function() {
      document.body.style.zoom = 1 / window.devicePixelRatio;
      this.scene = new THREE.Scene();
      this.camera = new THREE.OrthographicCamera(0, this.width(), this.height(), 0, 0, 200000);
      this.camera.position.z = 500;
      this.camera.updateProjectionMatrix();
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.width(), this.height());
      document.body.appendChild(this.renderer.domElement);
      window.addEventListener('resize', this.resize);
      return this.scene.add(new THREE.AmbientLight(0x666666));
    };

    Main.prototype.resize = function() {
      this.renderer.setSize(this.width(), this.height());
      this.camera.left = 0;
      this.camera.right = this.width();
      this.camera.top = this.height();
      this.camera.bottom = 0;
      this.camera.updateProjectionMatrix();
      this.scene.scale.x = this.scale();
      this.scene.scale.y = this.scale();
      return this.input.scale_factor = 1 / this.scale();
    };

    Main.prototype.gemsLoaded = function() {
      return this.menu.open('main');
    };

    Main.prototype.showAbout = function() {
      var about;
      about = document.getElementById('about');
      about.style.fontSize = (this.width() / 23) + "px";
      about.style.lineHeight = (this.width() / 23 * 1.5) + "px";
      return about.className += ' show';
    };

    Main.prototype.closeAbout = function(e) {
      document.getElementById('about').className = '';
      e.stopPropagation();
      return this.menu.open('main');
    };

    Main.prototype.renderLoop = function(t) {
      requestAnimationFrame(this.renderLoop);
      TWEEN.update(t);
      this.roaming_light.update(t);
      this.grid.update(t);
      this.timer.update(t);
      this.multiplier_display.update(t);
      return this.renderer.render(this.scene, this.camera);
    };

    Main.prototype.gridReady = function() {
      return this.timer.start();
    };

    Main.prototype.start = function() {
      this.score.reset();
      this.grid.show();
      this.grid.addGems();
      this.progress_meter.show();
      this.timer.show();
      this.timer.setTime(60);
      this.score.levelUp();
      return this.score_board.show();
    };

    Main.prototype.nextLevel = function() {
      this.score.levelUp();
      this.timer.setTime(60);
      return this.grid.addGems();
    };

    Main.prototype.goalReached = function(e) {
      this.timer.stop();
      return this.grid.complete();
    };

    Main.prototype.timeDanger = function() {
      return this.grid.shakeGems();
    };

    Main.prototype.gameOver = function() {
      this.grid.hide();
      this.timer.hide();
      this.timer.stop();
      this.progress_meter.hide();
      this.score_board.hide();
      return this.menu.open('main');
    };

    Main.prototype.timesUp = function() {
      return this.grid.dropGems();
    };

    return Main;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Main = Main;

  Menu = (function() {
    function Menu() {
      this.tweenTick = bind(this.tweenTick, this);
      this.chooseComplete = bind(this.chooseComplete, this);
      this.handleTouch = bind(this.handleTouch, this);
      var ref;
      this.object = new THREE.Object3D();
      this.fontcfg = {
        size: this.fontSize(),
        height: 10,
        curveSegments: 3,
        font: "droid sans",
        weight: "normal",
        style: "normal",
        bevelThickness: 10,
        bevelSize: 5,
        bevelEnabled: true,
        extrudeMaterial: 1
      };
      this.chosen = null;
      this.menu = {
        main: [
          {
            label: 'New Game',
            color: 'green',
            exec: (function(_this) {
              return function() {
                _this.cascade.stop();
                return GEMCRUSHER.start();
              };
            })(this)
          }, {
            label: 'About',
            color: 'teal',
            exec: function() {
              return GEMCRUSHER.showAbout();
            }
          }, {
            label: 'Quit',
            color: 'red',
            exec: typeof navigator !== "undefined" && navigator !== null ? (ref = navigator.app) != null ? ref.exitApp : void 0 : void 0
          }
        ]
      };
      this.outline = new THREE.MeshBasicMaterial({
        color: 'black',
        side: THREE.BackSide
      });
      this.meshes = [];
      this.busy = false;
      GEMCRUSHER.input.addEventListener('touchstart', this.handleTouch);
    }

    Menu.prototype.handleTouch = function(e) {
      var i;
      if (this.menuIsOpen()) {
        i = this.checkTouch(e.y);
        if (i !== false) {
          return this.choose(i);
        }
      }
    };

    Menu.prototype.fontSize = function() {
      return GEMCRUSHER.base_width / 12;
    };

    Menu.prototype.center = function(width) {
      return GEMCRUSHER.base_width / 2 - width / 2;
    };

    Menu.prototype.open = function(menu) {
      var i, item, j, l, len, len1, ref, ref1, results;
      if (!this.cascade) {
        if (this.cascade == null) {
          this.cascade = new GemCrusher.GemCascade(50);
        }
        this.object.add(this.cascade.object);
      }
      this.cascade.start();
      this.current = this.menu[menu];
      ref = this.current;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (!item.object) {
          this.createItem(item, i);
        }
      }
      ref1 = this.current;
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        item = ref1[l];
        item.object.scale.x = 1;
        item.object.scale.y = 1;
        item.object.position.x = this.center(item.width);
        results.push(this.object.add(item.object));
      }
      return results;
    };

    Menu.prototype.createItem = function(item, i) {
      var j, len, letter, letters, mat;
      mat = new THREE.MeshPhongMaterial({
        color: item.color,
        ambient: item.color,
        shininess: 60
      });
      item.object = new THREE.Object3D();
      letters = (function() {
        var j, len, ref, results;
        ref = item.label.split('');
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          letter = ref[j];
          results.push(this.createLetter(letter, mat));
        }
        return results;
      }).call(this);
      item.width = 0;
      for (j = 0, len = letters.length; j < len; j++) {
        letter = letters[j];
        if (letter) {
          letter.position.x = item.width;
          item.object.add(letter);
          item.width += (letter.children[0].geometry.boundingBox.max.x - letter.children[0].geometry.boundingBox.min.x) + this.fontSize() / 8;
        } else {
          item.width += this.fontSize() / 8;
        }
      }
      item.object.position.x = this.center(item.width);
      return item.object.position.y = i * this.fontSize() * -2 + (GEMCRUSHER.base_width + GEMCRUSHER.base_width * GEMCRUSHER.aspect()) / 2 + this.current.length * this.fontSize() / 2;
    };

    Menu.prototype.createLetter = function(letter, mat) {
      var geom, h, hd, mesh, object, os, outline_mesh, w, wd;
      if (letter === ' ') {
        return;
      }
      os = 1.15;
      object = new THREE.Object3D();
      geom = new THREE.BufferGeometry().fromGeometry(new THREE.TextGeometry(letter, this.fontcfg));
      geom.computeBoundingBox();
      w = geom.boundingBox.max.x - geom.boundingBox.min.x;
      h = geom.boundingBox.max.y - geom.boundingBox.min.y;
      wd = w * os - w;
      hd = h * os - h;
      mesh = new THREE.Mesh(geom, mat);
      mesh.position.x = wd / 2;
      mesh.position.y = hd / 2;
      mesh.position.z = 2;
      outline_mesh = new THREE.Mesh(geom, this.outline);
      outline_mesh.position.z = -2;
      outline_mesh.scale.multiplyScalar(os);
      outline_mesh.geometry.computeBoundingBox();
      object.add(mesh);
      object.add(outline_mesh);
      return object;
    };

    Menu.prototype.choose = function(index) {
      this.chosen = index;
      return this.choseAnimation();
    };

    Menu.prototype.chooseComplete = function() {
      var exec;
      exec = this.current[this.chosen].exec;
      this.chosen = null;
      this.current = null;
      return typeof exec === "function" ? exec() : void 0;
    };

    Menu.prototype.choseAnimation = function() {
      var chosen_to, chosen_tween, close_to, close_tween, i, item, j, len, ref;
      this.tween_data = {};
      close_to = {};
      chosen_to = {};
      ref = this.current;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        this.tween_data[i] = 1;
        if (i !== this.chosen) {
          close_to[i] = 0;
        } else {
          chosen_to[i] = 0;
        }
      }
      close_tween = new TWEEN.Tween(this.tween_data).to(close_to, 500).easing(TWEEN.Easing.Linear.None).onUpdate(this.tweenTick);
      close_tween.start();
      chosen_tween = new TWEEN.Tween(this.tween_data).to(chosen_to, 1000).easing(TWEEN.Easing.Back.In).onUpdate(this.tweenTick).onComplete(this.chooseComplete);
      return chosen_tween.start();
    };

    Menu.prototype.tweenTick = function() {
      var i, ref, results, s;
      ref = this.tween_data;
      results = [];
      for (i in ref) {
        s = ref[i];
        if (s !== 0) {
          this.current[i].object.scale.x = s;
          this.current[i].object.scale.y = s;
          results.push(this.current[i].object.position.x = this.center(this.current[i].width * s));
        } else {
          results.push(this.object.remove(this.current[i].object));
        }
      }
      return results;
    };

    Menu.prototype.menuIsOpen = function() {
      return this.current !== null && this.chosen === null;
    };

    Menu.prototype.checkTouch = function(ty) {
      var i, item, j, len, ref;
      if (ty > this.fontSize() + this.current[0].object.position.y) {
        return false;
      }
      ref = this.current;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (ty > item.object.position.y) {
          return i;
        }
      }
      return false;
    };

    return Menu;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Menu = Menu;

  MultiplierDisplay = (function() {
    function MultiplierDisplay() {
      this.scoreChange = bind(this.scoreChange, this);
      var color, j, len, ref;
      this.object = new THREE.Object3D();
      this.max_age = 2000;
      this.fontcfg = {
        size: this.fontSize(),
        height: 10,
        curveSegments: 3,
        font: "droid sans",
        weight: "normal",
        style: "normal",
        bevelThickness: 1,
        bevelSize: this.fontSize() * 0.125,
        bevelEnabled: true,
        extrudeMaterial: 1
      };
      this.buffer_font = new THREE.FontBufferGeometry(this.fontcfg, '0123456789X');
      this.materials = {};
      ref = ['red', 'teal', 'green', 'yellow'];
      for (j = 0, len = ref.length; j < len; j++) {
        color = ref[j];
        this.materials[color] = new THREE.MeshPhongMaterial({
          color: color,
          ambient: color,
          transparent: true,
          opacity: 1.0,
          shininess: 60
        });
      }
      this.meshes = [];
      GEMCRUSHER.score.addEventListener('scorechange', this.scoreChange);
    }

    MultiplierDisplay.prototype.fontSize = function() {
      return this.cellSize() / 2;
    };

    MultiplierDisplay.prototype.cellSize = function() {
      return GEMCRUSHER.base_width / GEMCRUSHER.grid_width;
    };

    MultiplierDisplay.prototype.color = function(c) {
      switch (c) {
        case 2:
          return 'red';
        case 3:
          return 'teal';
        case 4:
          return 'green';
        default:
          return 'yellow';
      }
    };

    MultiplierDisplay.prototype.scoreChange = function(e) {
      var mesh;
      if (e.x && e.y && e.chain > 1) {
        mesh = this.buffer_font.buildMesh(e.chain + "X", this.materials[this.color(e.chain)]);
        mesh.position.x = (e.x + 0.125) * this.cellSize();
        mesh.position.y = (e.y + 1.25) * this.cellSize();
        mesh.position.z = 100;
        this.object.add(mesh);
        return this.meshes.push({
          object: mesh
        });
      }
    };

    MultiplierDisplay.prototype.update = function(t) {
      var child, diff, j, l, len, len1, mesh, new_meshes, perc, ref, ref1;
      new_meshes = [];
      ref = this.meshes;
      for (j = 0, len = ref.length; j < len; j++) {
        mesh = ref[j];
        if (mesh.created_at == null) {
          mesh.created_at = t;
        }
        diff = t - mesh.created_at;
        perc = diff / this.max_age;
        mesh.object.scale.x = perc / 2 + 1;
        mesh.object.scale.y = perc / 2 + 1;
        mesh.object.rotation.z = -perc / 2;
        ref1 = mesh.object.children;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          child = ref1[l];
          child.material.opacity = 1.5 - perc;
        }
        if (diff < this.max_age) {
          new_meshes.push(mesh);
        } else {
          this.object.remove(mesh.object);
        }
      }
      return this.meshes = new_meshes;
    };

    return MultiplierDisplay;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.MultiplierDisplay = MultiplierDisplay;

  ProgressMeter = (function() {
    function ProgressMeter() {
      this.tweenTick = bind(this.tweenTick, this);
      this.showTweenTick = bind(this.showTweenTick, this);
      this.scoreChange = bind(this.scoreChange, this);
      this.cleared = 0;
      this.goal = 0;
      this.width = GEMCRUSHER.base_width / 8;
      this.length = GEMCRUSHER.base_width - this.width / 2;
      this.buildObject();
      GEMCRUSHER.score.addEventListener('scorechange', this.scoreChange);
    }

    ProgressMeter.prototype.scoreChange = function(e) {
      this.cleared = e.cleared;
      this.goal = e.goal;
      return this.resizeBar();
    };

    ProgressMeter.prototype.perc = function() {
      switch (false) {
        case this.cleared / this.goal !== 0:
          return 0.0001;
        case !(this.cleared / this.goal > 1):
          return 1;
        default:
          return this.cleared / this.goal;
      }
    };

    ProgressMeter.prototype.show = function() {
      return this.animate(-this.width / 2, this.width / 2);
    };

    ProgressMeter.prototype.hide = function() {
      return this.animate(this.width / 2, -this.width / 2);
    };

    ProgressMeter.prototype.animate = function(starty, endy) {
      var to, tween;
      this.show_tween = {
        y: starty
      };
      to = {
        y: endy
      };
      tween = new TWEEN.Tween(this.show_tween).to(to, 1000).easing(TWEEN.Easing.Linear.None).onUpdate(this.showTweenTick);
      return tween.start();
    };

    ProgressMeter.prototype.showTweenTick = function() {
      return this.object.position.y = this.show_tween.y;
    };

    ProgressMeter.prototype.resizeBar = function() {
      var tween;
      this.tween_data = {
        scale: this.cylinder.scale.y,
        position: this.cylinder.position.y
      };
      tween = new TWEEN.Tween(this.tween_data).to({
        scale: this.perc(),
        position: this.posY()
      }, 500).easing(TWEEN.Easing.Linear.None).onUpdate(this.tweenTick);
      return tween.start();
    };

    ProgressMeter.prototype.tweenTick = function() {
      this.cylinder.scale.y = this.tween_data.scale;
      this.cylinder.position.y = this.tween_data.position;
      if (this.tween_data.scale === 1) {
        this.cylinder.material.color.setStyle("yellow");
        return this.cylinder.material.ambient.setStyle("yellow");
      } else {
        this.cylinder.material.color.setStyle("teal");
        return this.cylinder.material.ambient.setStyle("teal");
      }
    };

    ProgressMeter.prototype.posY = function() {
      return this.length / 2 - this.length * this.perc() / 2;
    };

    ProgressMeter.prototype.buildObject = function() {
      var cyl_hole, cyl_hole_geom, cyl_hole_mat, cyl_outline, cyl_outline_geom, cyl_outline_mat, geometry, material;
      this.object = new THREE.Object3D();
      this.object.position.x = GEMCRUSHER.base_width / 2;
      this.object.position.y = -this.width / 2;
      this.object.rotation.z = Math.PI / 2;
      geometry = new THREE.CylinderGeometry(this.width / 4, this.width / 4, this.length, 4);
      material = new THREE.MeshPhongMaterial({
        color: 'teal',
        ambient: 'teal',
        shininess: 60
      });
      this.cylinder = new THREE.Mesh(geometry, material);
      this.object.add(this.cylinder);
      cyl_hole_mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.5
      });
      cyl_hole_geom = new THREE.PlaneBufferGeometry(this.width / 2, this.length);
      cyl_hole = new THREE.Mesh(cyl_hole_geom, cyl_hole_mat);
      cyl_hole.position.z = -1;
      this.object.add(cyl_hole);
      cyl_outline_mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.2
      });
      cyl_outline_geom = new THREE.PlaneBufferGeometry(this.width, GEMCRUSHER.base_width);
      cyl_outline = new THREE.Mesh(cyl_outline_geom, cyl_outline_mat);
      cyl_outline.position.z = -1;
      return this.object.add(cyl_outline);
    };

    return ProgressMeter;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.ProgressMeter = ProgressMeter;

  RoamingLight = (function() {
    function RoamingLight(scale) {
      this.scale = scale;
      this.object = new THREE.DirectionalLight(0xffffff, 1);
      this.object.position.z = scale / 2;
      this.speed = 2500;
    }

    RoamingLight.prototype.xPos = function(t) {
      return Math.sin(t / this.speed) * this.scale;
    };

    RoamingLight.prototype.yPos = function(t) {
      return Math.cos(t / (this.speed * 2)) * this.scale;
    };

    RoamingLight.prototype.xOffset = function() {
      return GEMCRUSHER.input.orientation.gamma * (Math.PI / 180) * -1 * this.scale;
    };

    RoamingLight.prototype.yOffset = function() {
      return GEMCRUSHER.input.orientation.beta * (Math.PI / 180) * this.scale;
    };

    RoamingLight.prototype.update = function(t) {
      this.object.position.x = this.xPos(t) + this.xOffset();
      return this.object.position.y = this.yPos(t) + this.yOffset();
    };

    return RoamingLight;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.RoamingLight = RoamingLight;

  ScoreBoard = (function() {
    function ScoreBoard() {
      this.showTweenTick = bind(this.showTweenTick, this);
      this.scoreChange = bind(this.scoreChange, this);
      this.fontcfg = {
        size: this.fontSize(),
        height: 10,
        curveSegments: 3,
        font: "droid sans",
        weight: "normal",
        style: "normal",
        bevelThickness: 1,
        bevelSize: 1,
        bevelEnabled: true,
        extrudeMaterial: 1
      };
      this.buffer_font = new THREE.FontBufferGeometry(this.fontcfg, '0123456789/');
      this.material = new THREE.MeshPhongMaterial({
        color: 'yellow',
        ambient: 'yellow',
        shininess: 60
      });
      this.objects = {};
      this.meshes = {};
      this.buildObjects();
      GEMCRUSHER.score.addEventListener('scorechange', this.scoreChange);
    }

    ScoreBoard.prototype.fontSize = function() {
      return this.height() * 0.12;
    };

    ScoreBoard.prototype.baseX = function() {
      return -this.width() / 2;
    };

    ScoreBoard.prototype.baseY = function() {
      return -this.height() / 2;
    };

    ScoreBoard.prototype.hiddenX = function() {
      return -this.width() / 2;
    };

    ScoreBoard.prototype.shownX = function() {
      return this.width() / 2 * 1.125;
    };

    ScoreBoard.prototype.buildObjects = function() {
      var i, j, label, label_geom, label_mesh, len, ref, results, text_label;
      this.object = new THREE.Object3D();
      this.object.position.z = -90000;
      this.buildBackdrop();
      this.object.position.x = this.hiddenX();
      this.object.position.y = GEMCRUSHER.base_width + this.height() / 2 + GEMCRUSHER.base_width / 8 * 1.125;
      ref = ['score', 'max_chain', 'cleared', 'level'];
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        label = ref[i];
        text_label = label.split('_').join(' ');
        label_geom = new THREE.BufferGeometry().fromGeometry(new THREE.TextGeometry(text_label, this.fontcfg));
        label_mesh = new THREE.Mesh(label_geom, this.material);
        label_mesh.position.x = this.baseX() + this.fontSize() * 1.5;
        label_mesh.position.y = this.baseY() + this.fontSize() * 1.5 * (i + 1);
        this.object.add(label_mesh);
        this.objects[label] = new THREE.Object3D();
        this.objects[label].position.x = this.fontSize() * 1.5;
        this.objects[label].position.y = this.baseY() + this.fontSize() * 1.5 * (i + 1);
        results.push(this.object.add(this.objects[label]));
      }
      return results;
    };

    ScoreBoard.prototype.width = function() {
      return GEMCRUSHER.base_width * 0.5;
    };

    ScoreBoard.prototype.height = function() {
      return GEMCRUSHER.base_width * (4 / 15);
    };

    ScoreBoard.prototype.buildBackdrop = function() {
      var geom, mat;
      mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.2
      });
      geom = new THREE.PlaneBufferGeometry(this.width(), this.height());
      this.object.add(new THREE.Mesh(geom, mat));
      mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.5
      });
      geom = new THREE.PlaneBufferGeometry(this.width() * 0.9, this.height() * 0.9);
      return this.object.add(new THREE.Mesh(geom, mat));
    };

    ScoreBoard.prototype.scoreChange = function(e) {
      this.updateNumber('score', e.score);
      this.updateNumber('max_chain', e.max_chain);
      this.updateNumber('cleared', e.cleared + " / " + e.goal);
      return this.updateNumber('level', e.level);
    };

    ScoreBoard.prototype.updateNumber = function(type, num) {
      if (this.meshes[type]) {
        this.objects[type].remove(this.meshes[type]);
      }
      this.meshes[type] = this.buffer_font.buildMesh(num.toString(), this.material);
      return this.objects[type].add(this.meshes[type]);
    };

    ScoreBoard.prototype.show = function() {
      return this.animate(this.hiddenX(), this.shownX());
    };

    ScoreBoard.prototype.hide = function() {
      return this.animate(this.shownX(), this.hiddenX());
    };

    ScoreBoard.prototype.animate = function(startx, endx) {
      var to, tween;
      this.show_tween = {
        x: startx
      };
      to = {
        x: endx
      };
      tween = new TWEEN.Tween(this.show_tween).to(to, 1000).easing(TWEEN.Easing.Linear.None).onUpdate(this.showTweenTick);
      return tween.start();
    };

    ScoreBoard.prototype.showTweenTick = function() {
      return this.object.position.x = this.show_tween.x;
    };

    return ScoreBoard;

  })();

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.ScoreBoard = ScoreBoard;

  Score = (function(superClass) {
    extend(Score, superClass);

    function Score() {
      this.reset();
      this.last_updated = 0;
    }

    Score.prototype.worth = function(cleared) {
      return (cleared - 2) * cleared * (this.chain + 1) * 100;
    };

    Score.prototype.updateChain = function() {
      this.chain += 1;
      return this.max_chain = this.chain > this.max_chain ? this.chain : this.max_chain;
    };

    Score.prototype.add = function(cleared, x, y) {
      this.score += this.worth(cleared);
      this.cleared += cleared;
      this.updateChain();
      this.dispatchEvent(this.scoreEvent(x, y));
      if (this.cleared >= this.goal()) {
        return this.dispatchEvent(this.goalEvent(x, y));
      }
    };

    Score.prototype.reset = function() {
      this.score = 0;
      this.cleared = 0;
      this.chain = 0;
      this.level = 0;
      return this.max_chain = 0;
    };

    Score.prototype.levelUp = function() {
      this.level += 1;
      this.cleared = 0;
      this.chain = 0;
      return this.dispatchEvent(this.scoreEvent());
    };

    Score.prototype.goal = function() {
      return 50 + (this.level - 1) * 5;
    };

    Score.prototype.scoreEvent = function(x, y) {
      return {
        type: 'scorechange',
        level: this.level,
        score: this.score,
        cleared: this.cleared,
        chain: this.chain,
        max_chain: this.max_chain,
        goal: this.goal(),
        x: x,
        y: y
      };
    };

    Score.prototype.goalEvent = function(x, y) {
      return {
        type: 'goalreached',
        level: this.level,
        score: this.score,
        cleared: this.cleared,
        chain: this.chain,
        max_chain: this.max_chain,
        goal: this.goal(),
        x: x,
        y: y
      };
    };

    return Score;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Score = Score;

  FontBufferGeometry = (function() {
    function FontBufferGeometry(parameters, prebuild_chars) {
      if (prebuild_chars == null) {
        prebuild_chars = '';
      }
      this.parameters = parameters;
      this.geometries = {};
      this.preBuildGeometries(prebuild_chars.split(''));
    }

    FontBufferGeometry.prototype.preBuildGeometries = function(chararray) {
      var char, j, len, results;
      results = [];
      for (j = 0, len = chararray.length; j < len; j++) {
        char = chararray[j];
        results.push(this.geometries[char] = this.buildGeometry(char));
      }
      return results;
    };

    FontBufferGeometry.prototype.buildGeometry = function(char) {
      var object;
      object = {};
      object.geometry = new THREE.BufferGeometry().fromGeometry(new THREE.TextGeometry(char, this.parameters));
      object.geometry.computeBoundingBox();
      object.width = object.geometry.boundingBox.max.x - object.geometry.boundingBox.min.x;
      return object;
    };

    FontBufferGeometry.prototype.buildMesh = function(string, mat) {
      var base, char, j, len, letter, mesh, pos, ref;
      mesh = new THREE.Object3D();
      pos = 0;
      ref = string.split('');
      for (j = 0, len = ref.length; j < len; j++) {
        char = ref[j];
        if (char === ' ') {
          pos += this.parameters.height / 2;
        } else {
          if ((base = this.geometries)[char] == null) {
            base[char] = this.buildGeometry(char);
          }
          letter = new THREE.Mesh(this.geometries[char].geometry, mat);
          letter.position.x = pos;
          pos += this.geometries[char].width + this.parameters.height / 4;
          mesh.add(letter);
        }
      }
      return mesh;
    };

    return FontBufferGeometry;

  })();

  if (window.THREE == null) {
    window.THREE = {};
  }

  THREE.FontBufferGeometry = FontBufferGeometry;

  Timer = (function(superClass) {
    extend(Timer, superClass);

    function Timer() {
      this.showTweenTick = bind(this.showTweenTick, this);
      this.time = 0;
      this.start_time = null;
      this.fontcfg = {
        size: this.height() * 0.5,
        height: 10,
        curveSegments: 3,
        font: "droid sans",
        weight: "normal",
        style: "normal",
        bevelThickness: 10,
        bevelSize: 5,
        bevelEnabled: true,
        extrudeMaterial: 1
      };
      this.material = new THREE.MeshPhongMaterial({
        color: 'yellow',
        ambient: 'yellow',
        shininess: 60
      });
      this.outline_material = new THREE.MeshBasicMaterial({
        color: 'black',
        side: THREE.BackSide
      });
      this.digits = [this.buildDigits(), this.buildDigits()];
      this.buildObject();
    }

    Timer.prototype.width = function() {
      return GEMCRUSHER.base_width * 0.4;
    };

    Timer.prototype.height = function() {
      return GEMCRUSHER.base_width * (4 / 15);
    };

    Timer.prototype.digitColor = function() {
      switch (this.status()) {
        case 'ok':
          return 'green';
        case 'warning':
          return 'yellow';
        default:
          return 'red';
      }
    };

    Timer.prototype.updateClock = function() {
      var d, digit, i, j, k, len, ref, ref1, results;
      ref = this.remainingDigits();
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        digit = ref[i];
        ref1 = this.digits[i];
        for (k in ref1) {
          d = ref1[k];
          d.visible = false;
        }
        this.digits[i][digit].visible = true;
        this.digits[i][digit].children[0].material.color.setStyle(this.digitColor());
        results.push(this.digits[i][digit].children[0].material.ambient.setStyle(this.digitColor()));
      }
      return results;
    };

    Timer.prototype.buildDigits = function() {
      var d, digits, j;
      digits = {};
      for (d = j = 0; j <= 9; d = ++j) {
        digits[d] = this.buildDigit(d);
      }
      return digits;
    };

    Timer.prototype.buildDigit = function(d) {
      var geom, h, hd, mesh, object, os, outline_mesh, w, wd;
      os = 1.125;
      object = new THREE.Object3D();
      geom = new THREE.BufferGeometry().fromGeometry(new THREE.TextGeometry(d, this.fontcfg));
      geom.computeBoundingBox();
      w = geom.boundingBox.max.x - geom.boundingBox.min.x;
      h = geom.boundingBox.max.y - geom.boundingBox.min.y;
      wd = w * os - w;
      hd = h * os - h;
      mesh = new THREE.Mesh(geom, this.material);
      mesh.position.x = wd / 2;
      mesh.position.y = hd / 2;
      mesh.position.z = 50;
      outline_mesh = new THREE.Mesh(geom, this.outline_material);
      outline_mesh.position.z = 25;
      outline_mesh.scale.multiplyScalar(os);
      outline_mesh.geometry.computeBoundingBox();
      object.add(mesh);
      object.add(outline_mesh);
      object.visible = false;
      object.position.x = -w / 2;
      object.position.y = -h / 2;
      return object;
    };

    Timer.prototype.buildObject = function() {
      var backdrop, cell, digit, i, k;
      this.object = new THREE.Object3D();
      backdrop = this.buildBackdrop();
      this.object.add(backdrop);
      this.cells = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0; j <= 1; i = ++j) {
          cell = this.buildCell();
          cell.position.x = -this.width() / 4 + this.width() / 2 * i;
          ref = this.digits[i];
          for (k in ref) {
            digit = ref[k];
            cell.add(digit);
          }
          this.object.add(cell);
          results.push(cell);
        }
        return results;
      }).call(this);
      this.object.position.z = -90000;
      this.object.position.x = this.hiddenX();
      return this.object.position.y = GEMCRUSHER.base_width + this.height() / 2 + GEMCRUSHER.base_width / 8 * 1.125;
    };

    Timer.prototype.hiddenX = function() {
      return GEMCRUSHER.base_width + this.width() / 2;
    };

    Timer.prototype.shownX = function() {
      return GEMCRUSHER.base_width - this.width() / 2 * 1.125;
    };

    Timer.prototype.buildCell = function() {
      var geom, mat, mesh, object;
      object = new THREE.Object3D();
      mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.5
      });
      geom = new THREE.PlaneBufferGeometry(this.width() / 2 * 0.875, this.height() * 0.875);
      mesh = new THREE.Mesh(geom, mat);
      object.add(mesh);
      return object;
    };

    Timer.prototype.buildBackdrop = function() {
      var geom, mat;
      mat = new THREE.MeshBasicMaterial({
        color: 'grey',
        transparent: true,
        opacity: 0.2
      });
      geom = new THREE.PlaneBufferGeometry(this.width(), this.height());
      return new THREE.Mesh(geom, mat);
    };

    Timer.prototype.start = function() {
      this.start_time = this.updated_at;
      return this.last_remaining = -1;
    };

    Timer.prototype.stop = function() {
      return this.start_time = null;
    };

    Timer.prototype.elapsed = function() {
      return Math.floor((this.updated_at - this.start_time) / 1000);
    };

    Timer.prototype.remaining = function() {
      if (this.start_time === null) {
        return this.time;
      } else {
        return this.time - this.elapsed();
      }
    };

    Timer.prototype.remainingDigits = function() {
      var r;
      r = this.remaining().toString().split('');
      if (r.length === 1) {
        return ['0', r[0]];
      } else {
        return r;
      }
    };

    Timer.prototype.show = function() {
      return this.animate(this.hiddenX(), this.shownX());
    };

    Timer.prototype.hide = function() {
      return this.animate(this.shownX(), this.hiddenX());
    };

    Timer.prototype.animate = function(startx, endx) {
      var to, tween;
      this.show_tween = {
        x: startx
      };
      to = {
        x: endx
      };
      tween = new TWEEN.Tween(this.show_tween).to(to, 1000).easing(TWEEN.Easing.Linear.None).onUpdate(this.showTweenTick);
      return tween.start();
    };

    Timer.prototype.showTweenTick = function() {
      return this.object.position.x = this.show_tween.x;
    };

    Timer.prototype.setTime = function(time) {
      this.time = time;
      return this.updateClock();
    };

    Timer.prototype.status = function() {
      switch (false) {
        case !(this.remaining() > 30):
          return 'ok';
        case !(this.remaining() > 5):
          return 'warning';
        case !(this.remaining() > 0):
          return 'danger';
        default:
          return 'end';
      }
    };

    Timer.prototype.sendEvents = function() {
      if (this.status() === 'ok') {
        return;
      }
      return this.dispatchEvent({
        type: this.status()
      });
    };

    Timer.prototype.update = function(t) {
      this.updated_at = t;
      if (this.start_time === null) {
        return;
      }
      if (this.last_remaining !== this.remaining() && this.remaining() >= 0) {
        this.updateClock();
        this.last_remaining = this.remaining();
        return this.sendEvents();
      }
    };

    return Timer;

  })(THREE.EventDispatcher);

  if (window.GemCrusher == null) {
    window.GemCrusher = {};
  }

  GemCrusher.Timer = Timer;

}).call(this);
